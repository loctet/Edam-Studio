
\section{GUI Usage}

The EDAM Studio GUI (available at \url{http://localhost:3000} when running via Docker) 
supports editing EDAM models, generating Solidity code, and verifying model behavior.

\textbf{Editing the model.}
The model can be edited in three ways:
\begin{itemize}
  \item \textbf{Force-Directed Graph} or \textbf{GraphViz}: 
    The model is displayed as a graph. 
    Edit by dragging nodes and edges, or use the sidebar to add transitions and states.
  \item \textbf{Manual Editor}: 
    Enter the EDAM specification as text in the \texttt{Manual Editor} tab, 
    then click \texttt{View EDAM} to load it into the editor. 
    The text format uses a compact syntax (states, roles, variables, and transitions).
    If a model is saved in a .edam file, it can be loaded by clicking \texttt{Load EDAM File} 
    and selecting the file, conversaly, the model can be saved by clicking \texttt{Save EDAM File} 
    and selecting the file.
    The following is the format of a .edam file:
    \begin{lstlisting}
ModelName
Role1,Role2,Role3
variable1:type1, variable2:type2
[from_state] {userVar:role:mode}, guard, [external_calls] \
callerVar:operation(params){assignments} {user:role:mode} [to_state]
    \end{lstlisting}
    First line is the model name, second line is the roles, third line is the variables, 
    and the following lines are the transitions.
    The transitions are formatted as follows:
    \begin{lstlisting}
[from_state] {userVar:role:mode}, guard, [external_calls] \
callerVar:operation(params){assignments} {user:role:mode} [to_state]
    \end{lstlisting}
    The \texttt{from\_state} is the source state, the \texttt{userVar:role:mode} is the user and role and mode, 
    the \texttt{guard} is the guard expression, the \texttt{external\_calls} are the external calls, 
    the \texttt{callerVar:operation(params)} is the caller variable and operation and parameters, 
    the \texttt{assignments} are the assignments, and the \texttt{to\_state} is the target state.

  \item \textbf{JSON Editor}: 
  The bottom panel provides a JSON editor for direct structural editing. 
  Changes are reflected in the graph 
  (Select some examples from the available models 
  in the \texttt{edams-models} repository to see the JSON format).
\end{itemize}

\noindent\textbf{Generating code.}
Add the desired model(s) to the \texttt{Generation List} via \texttt{Add to Generation List}, then click \texttt{Generate Code} in the header. After generation, the results appear with two tabs:
\begin{itemize}
\item \textbf{Generated Code}: View the generated Solidity contracts. Use \texttt{Download Generated ZIP} to save the code (contracts, tests, and configuration) locally.
\item \textbf{Run Solidity Test}: Execute the generated tests on the server and view pass/fail results.
\end{itemize}

\noindent\textbf{Running a trace test.}
To verify model behavior without generating full code, click \texttt{Run A Trace Test} (bottom-right). Enter trace commands in the text area (e.g., \texttt{p1>Token1.deploy [] [10]}) and click \texttt{Test Trace} to execute. The tool simulates the trace against the model and reports the outcome.

\section{CLI Usage}

The EDAM Studio CLI provides two main interfaces for command-line workflows: 
\texttt{edam-cli} for code generation, and \texttt{CLI/cli.sh} 
for running tests, mutation analysis, and experiment data processing.

\noindent\textbf{Code generation (\texttt{edam-cli}).}
When running via Docker, use \texttt{edam-cli} to generate Solidity contracts from EDAM models:
\begin{lstlisting}
docker exec -it edam-studio edam-cli \
<model1> [model2] ... --mode <3|4> [options]
\end{lstlisting}
Models can be predefined names (e.g., \texttt{assettransfer}, \texttt{c20}, \texttt{amm}).
The \texttt{--mode} parameter is required: 
1 (single trace), 2 (few traces), 3 (many traces), or 4 (all models). 
Generated ZIP files appear in \texttt{/app/Studio/Generated-code/} inside the container. 
See Table~\ref{tab:cli-params} for all optional parameters.

\noindent\textbf{Auxiliary commands (\texttt{cli.sh}).}
From within the container (or locally with \texttt{cd Studio}), use:
\begin{itemize}
  \item \texttt{.generate edams <models> --mode <3|4> [options]}: 
    Generate code (equivalent to \texttt{edam-cli}).
  \item \texttt{.run test <zip\_file> [test|coverage]}: 
    Extract a generated ZIP, run \texttt{npm install}, 
    then execute Hardhat tests or coverage.
  \item \texttt{.run resumo <zip\_file>}: 
    Run ReSuMo mutation testing on a generated ZIP file.
  \item \texttt{.run experiment\_data [--mutation <zip\_file>]}: 
    Process all ZIPs in \texttt{EXPERIMENT\_DATA/Generated Code.zip} (tests and coverage; 
    optionally run mutation on a specific ZIP).
\end{itemize}
Example (inside container):
\begin{lstlisting}
docker exec -it edam-studio bash -c \
"cd /app/Studio && CLI/cli.sh .run test assettransfer_0.35_1.zip test"
\end{lstlisting}

List of all models available in the \texttt{edams-models} repository:
\begin{table}[ht]
\centering
\caption{List of all models available in the \texttt{edams-models} repository.}
\label{tab:models}
\begin{tabular}{@{}ll@{}}
\hline
\textbf{Model Name} & \textbf{Description} \\
\hline
\texttt{assettransfer} & Asset transfer contract \\
\texttt{basicprovenance} & Basic provenance tracking \\
\texttt{defectivecounter} & Defective counter (testing example) \\
\texttt{digital\_locker} & Digital locker contract \\
\texttt{frequentflyer} & Frequent flyer program \\
\texttt{helloblockchain} & Hello blockchain example \\
\texttt{refrigeratedtransport} & Refrigerated transport tracking \\
\texttt{simplemarketplace} & Simple marketplace contract \\
\texttt{thermostatoperation} & Thermostat operation \\
\hline
\texttt{amm} & Automated Market Maker \\
\texttt{c20} & ERC-20 token contract \\
\texttt{c20\_2} & ERC-20 token variant \\
\texttt{simplewallet} & Simple wallet contract \\
\hline
\texttt{c1}, \texttt{c2}, \texttt{c3} & Example models in figure 1 from the paper \\
\texttt{cop} & Example model for figure 3 from the paper \\
\texttt{cpay} & Payment contract with C20 for figure 4 from the paper \\
\texttt{cm} & Case study model from the paper \\
\hline
\end{tabular}
\end{table}

To generate code for any of the models (except AMM, COP, CPAY, CM) in the table, use the following command:
\begin{lstlisting}
docker exec -it edam-studio edam-cli <model_name> --mode 4 [options]
\end{lstlisting}
Replace \texttt{<model\_name>} with the name of the model you want to generate code for.
The options are the same as the ones listed in Table~\ref{tab:cli-params}.
To generate code for models AMM, COP, CPAY, CM, use the following command:
\begin{lstlisting}
docker exec -it edam-studio edam-cli c20 c20\_2 amm --mode 3 [options]
\end{lstlisting}
Here we have to pass the network of all models. In the case of AMM, 
we have to pass the network of C20, C20\_2 and AMM. 
Likewise, for COP, we have to pass the network of C20 and COP,
for CPAY, we have to pass the network of C20 and CPAY,
for CM, we have to pass the network of C20 and CM.

\section{Reproduction of Experimental Claims}

For each experimental claim in the paper, 
the following commands and procedures enable reproduction:
\subsection{Running the Case Study}
The case study is run on the model \texttt{cm} with the following command:
\begin{lstlisting}
docker exec -it edam-studio edam-cli cm --mode 4
\end{lstlisting}
That will generate the code and the tests for the model \texttt{cm}.
To run the semantic on the model \texttt{cm}, we can use the following command:
\begin{lstlisting}
docker exec -it edam-studio bash -c \
  "cd /app/Studio/API/base_code && bash cmd_test_run_cm_c20.sh"
\end{lstlisting}
This will run the semantic on the model \texttt{cm} and the 
result will be the screenshot seen the case study section of the paper.

\subsection{Code Generation}

\textbf{Claim}: EDAM Studio generates Solidity smart contracts from EDAM models.

\noindent\textbf{Reproduction}: Using the Docker container:
\begin{lstlisting}
docker exec -it edam-studio edam-cli \
  assettransfer c20 basicprovenance --mode 4
\end{lstlisting}
Generated code (a ZIP file named 
\texttt{<ModelName>\_<new participant probability>\_<id>.zip} 
containing the generated code, tests, and configuration files) 
appears in \texttt{/app/Studio/Generated-code/} in the Docker container. 
The Zip file can be generated and downloaded from the GUI 
by adding the model to the \texttt{Generation List} and clicking on the \texttt{Download Generated ZIP} button.
For custom trace counts (as in the paper):
\begin{lstlisting}
docker exec -it edam-studio edam-cli <model_name> --mode 4 \
  --number_symbolic_traces 2000 --number_transition_per_trace 50 \
  --max_fail_try 5 --probability_new_participant 0.1 
\end{lstlisting}

\noindent\textbf{Command template}:
\begin{lstlisting}
docker exec -it edam-studio edam-cli <model1> [model2] ... \
  --mode <3|4> [options]
\end{lstlisting}

Table~\ref{tab:cli-params} lists all optional parameters for code generation.
\begin{table}[ht]
\centering
\caption{Full parameters for \texttt{edam-cli} code generation.}
\label{tab:cli-params}
\begin{tabular}{@{}llp{6.5cm}@{}}
\hline
\textbf{Parameter} & \textbf{Default} & \textbf{Description} \\
\hline
\multicolumn{3}{l}{\textit{Required}} \\
\texttt{--mode} & --- & Generation mode: 3 (all models form one network), 4 (Each model form one network) \\
\hline
\multicolumn{3}{l}{\textit{Symbolic trace generation}} \\
\texttt{--number\_symbolic\_traces} & 200 & Number of symbolic traces to generate per model \\
\texttt{--number\_transition\_per\_trace} & 10 & Maximum transitions per symbolic trace \\
\texttt{--number\_real\_traces} & 5 & Number of real traces for validation \\
\texttt{--max\_fail\_try} & 2 & Maximum retries on trace generation failure \\
\hline
\multicolumn{3}{l}{\textit{Probability parameters}} \\
\texttt{--probability\_new\_participant} & 0.35 & Probability of adding a new participant in a trace \\
\texttt{--probability\_right\_participant} & 0.7 & Probability of selecting the correct participant \\
\texttt{--probability\_true\_for\_bool} & 0.5 & Probability of \texttt{true} for boolean values \\
\hline
\multicolumn{3}{l}{\textit{Value bounds for generated data}} \\
\texttt{--min\_int\_value} & 0 & Minimum integer value in generated tests \\
\texttt{--max\_int\_value} & 100 & Maximum integer value in generated tests \\
\texttt{--max\_gen\_array\_size} & 10 & Maximum size of generated arrays \\
\texttt{--min\_gen\_string\_length} & 5 & Minimum length of generated strings \\
\texttt{--max\_gen\_string\_length} & 10 & Maximum length of generated strings \\
\hline
\multicolumn{3}{l}{\textit{Test generation options}} \\
\texttt{--add\_pi\_to\_test} & off & Add process invariants to generated tests \\
\texttt{--add\_test\_of\_state} & on & Include state assertions in tests \\
\texttt{--add\_test\_of\_variables} & on & Include variable assertions in tests \\
\hline
\texttt{--z3\_check\_enabled} & on & Enable Z3 SMT solver checks during trace generation \\
\hline
\end{tabular}
\end{table}

\subsection{Pre-generated Code and Data}

\textbf{Claim}: The data in \texttt{EXPERIMENT\_DATA/} 
corresponds to the paper's experiments.

\noindent\textbf{Reproduction}: 
The archives \texttt{Generated Code.zip}, \texttt{Mutations.zip}, and \texttt{Excels Mutations Results.zip} contain the exact outputs used in the paper. No regeneration needed for verification. 

\noindent\textbf{Running tests and mutation on pre-generated data}:
To run tests and coverage for all pre-generated zip files in \texttt{EXPERIMENT\_DATA/Generated Code.zip}, use:
\begin{lstlisting}
docker exec -it edam-studio bash -c \ 
  "cd /app/Studio && CLI/cli.sh .run experiment_data"
\end{lstlisting}
This command will:
\begin{enumerate}
  \item Extract \texttt{EXPERIMENT\_DATA/Generated Code.zip}
  \item For each zip file found:
  \begin{itemize}
    \item Extract the zip file
    \item Run \texttt{npm install}
    \item Run \texttt{npx hardhat test}
    \item Run \texttt{npx hardhat coverage}
  \end{itemize}
  \item Display a summary of results for all processed files
\end{enumerate}

\noindent\textbf{Running mutation testing on a specific pre-generated zip}:
To run mutation testing (ReSuMo) on a specific zip file from the pre-generated data:
\begin{lstlisting}
docker exec -it edam-studio bash -c \ 
  "cd /app/Studio && CLI/cli.sh .run experiment_data --mutation <zip_filename>"
\end{lstlisting}
Replace \texttt{<zip\_filename>} with the name of the zip file (e.g., \texttt{assettransfer\_0.35\_1.zip}). The command will copy the zip to the Generated-code directory, run ReSuMo mutation testing, and clean up afterward.

For the experiments in the paper, the results are in the file 
\texttt{EXPERIMENT\_DATA/Mutation result - Recaps.xlsx}. 
Detailed per-operator results are in 
\texttt{EXPERIMENT\_DATA/Excels Mutations Results.zip}. 

Note that mutation testing is time consuming and can take several hours to complete 
for some models (e.g., AMM, COP, CPAY, CM), 
also depends on size of the test suite and the number of mutants.

\subsection{Mutation Testing Results}

\textbf{Claim}: Mutation scores and timing reported in tables/figures.

\noindent\textbf{Reproduction}: Open \texttt{EXPERIMENT\_DATA/Mutation 
result - Recaps.xlsx} for summary data. 
Detailed per-operator results are in \texttt{Excels Mutations Results.zip}. 
To reproduce mutation testing on a single model, 
using the Docker container:

\begin{lstlisting}
docker exec -it edam-studio bash -c \
  "cd /app/Studio && CLI/cli.sh .run resumo <ModelName>_<version>_<id>.zip"
\end{lstlisting}
(Replace \texttt{<ModelName>\_<version>\_<id>.zip} 
with an actual generated ZIP filename from \texttt{Generated-code/}.)

\subsection{Test Execution}

\textbf{Claim}: Generated tests execute successfully and achieve coverage.

\noindent\textbf{Reproduction}:
\begin{lstlisting}
docker exec -it edam-studio bash -c \
  "cd /app/Studio && CLI/cli.sh .run test <zip_file> test"
\end{lstlisting}
For coverage: \texttt{CLI/cli.sh .run test <zip\_file> coverage}.

\subsection{Timing Expectations}

Results may differ from the paper due to:
\begin{itemize}
\item Machine speed (CPU, disk I/O)
\item Non-deterministic symbolic trace generation (Z3 solver, random sampling)
\item Node/npm version differences
\end{itemize}
Code generation: typically 5--20 min per model. 
Testing: up to 20 min for 10k tests. 
Mutation: less than 2 h for most models; AMM can take days.